/*
 * symmetry.raphael.js
 * by mjhoy, 2010
 * 
 * requires: raphael, underscore.js
 */


(function (Raphael) {
  
  // helper function
  function degToRad(deg) {
    return (deg * (2 * Math.PI)) / 360;
  }

  // helper functions to get an element's x or y
  function getX(el) {
    return el.getBBox()['x'];
  }

  function getY(el) {
    return el.getBBox()['y'];
  }

  // -----
  // extend Raphael

  // rotateAround(deg, x, y)
  //
  // an implementation of rotate(deg, cx, cy) that uses translate
  // to allow for additive multiple rotations
  //
  // if available, uses information in the 'sym_attrs' property
  // (added to Raphael/iteration objects) to "pivot" around a 
  // root element.
  //
  // TODO: this function is a bit hard to follow as is,
  // needs cleanup.
  function rotateAround(degree, cx, cy) {
    var cos = Math.cos, sin = Math.sin,
    root, rootRotation, cur_x, cur_y, r_x, r_y, x1, y1, t,
    cx1, cy1;
    t = degToRad(parseInt(degree, 10));

    if (this.sym_attrs && this.sym_attrs.root) {
      // define cx and cy relative to root
      root = this.sym_attrs.root;
      rootRotate = root.rotate();

      // find the current x,y of this element
      cur_x = getX(this);
      cur_y = getY(this);

      // find the root x, y
      r_x = getX(root);
      r_y = getY(root);

      // if the root (pivot) element is already rotated,
      // the (cx) and (cy) parameters should be rotated along with.
      if (root.rotate()) {
        rootRotation = degToRad(root.rotate());
        cx1 = (cx * cos(rootRotation)) + (cy * sin(rootRotation));
        cy1 = (cy * cos(rootRotation)) + (cx * sin(rootRotation));
        cx = cx1;
        cy = cy1;
      }

      // get the difference
      cx = cx - (cur_x - r_x);
      cy = cy - (cur_y - r_y);

    }
    // rotation equation. given degree t, and the "pivot"
    // point of cx, cy, find the new x, y value.
    x1 = ((cx * cos(t)) - (cy * sin(t))) * -1;
    y1 = ((cx * sin(t)) + (cy * cos(t))) * -1;

    this.rotate(degree);

    this.translate((x1 + cx), (y1 + cy));
  }

  Raphael.el.rotateAround = rotateAround;

  // r_translate(x, y)
  //
  // A replacement translation function for Raphael elements
  // if a root property is defined (through the sym_attrs property)
  // then the translation is rotated accordingly.
  //
  // e.g., if the root is rotated 90 degrees, and the translation is
  // (10, 10): Imagine a line from (0, 0) to (10, 10), which is rotated
  // 90 degrees. Where does it now point? The rotated translation is
  // (-10, 10).
  //
  // This becomes Raphael's translate() function.
  //
  // The old translation function (which is still called) can be
  // reached at _oldTranslate(x, y).
  function r_translate(x, y) {
    if (this.sym_attrs && this.sym_attrs.root && this.sym_attrs.root.rotate()) {
      var cos = Math.cos, sin = Math.sin, root = this.sym_attrs.root,
      rootRotation, cx, cy;
      rootRotation = degToRad(root.rotate());

      // Rotate x, y
      cx = (x * cos(rootRotation)) + (-1 * y * sin(rootRotation));
      cy = (y * cos(rootRotation)) + (x * sin(rootRotation));
      x = cx;
      y = cy;
    }
    return this._oldTranslate(x, y);
  }
  Raphael.el._oldTranslate = Raphael.el.translate;
  Raphael.el.translate = r_translate;


  // ------
  // the iterate method
  //
  // called on a raphael object or an iteration
  //
  // returns an iteration object, of type 'iteration',
  // which mimics (somewhat) a Raphael element.
  //
  //   [transN] -> (optional) integer number of iterations
  //   [transFunc] -> transformation function
  //
  function iterate(transN, transFunc) {

    var _root = this; // the calling object (a raphael element or iteration group)
    var _elements = [];
    var _func, _n = 1;

    // ------------------------
    // Iteration methods
    // ------------------------

    // - setTransform(func, n)
    // set the transformation to be appled to the root element,
    // over n times.
    function setTransform(func, n) {
      if (n === undefined) { n = 1; }
      _func = func;
      _n = n;
      _apply();
    }

    // - root()
    // returns the 'root' element of an iteration (the object
    // whose iterate method was originally called)
    function root() {
      return _root; 
    }
    
    // - apply()
    // applies the transformation function again, reseting
    // any previous iterated elements.
    function apply() {
      _apply();
    }

    // - elements()
    // returns an array of all objects generated by
    // the iteration (this does not include the root)
    function elements() {
      return _elements;
    }

    function _apply() {
      _reset_elements();
      _.times(_n, function() {
        var last = _elements[_elements.length - 1] || _root;
        var c = last.clone();
        _set_sym_vars(c);
        _func.call(c);
        _elements.push(c);
      });
    }

    // Reset the current cloned element array
    function _reset_elements() {
      if (_elements.length > 0) {
        _.each(_elements, function(el) {
          el.remove();
        });
        _elements = [];
      }
    }

    function _set_sym_vars(el) {
      if (el['sym_attrs'] === undefined) {
        el['sym_attrs'] = {};
      }
      var s = el['sym_attrs'];
      s['root'] = _root;
    }
    
    // -----------------
    // Raphael methods
    // -----------------

    function rotate(degree, cx, cY) {
      if (degree === undefined) { return _root.rotate(); }
      var current = _root.rotate();
      _root.rotate(degree, cx, cY);
      _apply();
      return this;
    }

    function translate(dx, dy) {
      _root.translate(dx, dy);
      _apply();
    }

    function scale(dx, dy) {
      var out = _root.scale(dx, dy);
      _apply();
      return out;
    }

    function clone() {
      var c = iterate.call(_root.clone(), _n, _func);
      return c;
    }

    function remove() {
      _.each(_elements, function(el) {
        el.remove();
      });
      _root.remove();
      this.removed = true;
    }
    
    function attr() {
      return _root.attr();
    }

    function getBBox() {
      return _root.getBBox(); // TODO... actually make this right? (just used for x/y currently)
    }

    // Interpret arguments
    if (transFunc && typeof transFunc === "function") {
      if (transN === undefined) { transN = 1; }
      setTransform(transFunc, transN);
    } else if (typeof transN === "function") {
      setTransform(transN, 1);
    } else {
      throw "no transformation function given";
    }

    // Set public methods
    return {
      setTransform: setTransform,
      apply: apply,
      root: root,
      elements: elements,

      iterate: iterate,
      translate: translate,
      scale: scale,
      rotate: rotate,
      rotateAround: rotateAround,
      clone: clone,
      remove: remove,
      attr: attr,
      getBBox: getBBox,
      removed: false, // TODO: should copy from root element?
      type: "iteration"
    };

  }

  Raphael.el.iterate = iterate;

}(Raphael));
